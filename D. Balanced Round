#include<bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
template<class Fun> class y_combinator_result {
 Fun fun_;
public:
template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}
template<class ...Args> decltype(auto) operator()(Args &&...args) {
   return fun_(std::ref(*this), std::forward<Args>(args)...);
    
      }
};
template<class Fun> decltype(auto) y_combinator(Fun &&fun) {
  return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); 
} // adding y-combinator 
using namespace __gnu_pbds;
using namespace std;
const int MOD = 1000000007;
const int INP = 1e9;
#define ll long long
#pragma GCC optimize("O3,unroll-loops")
#define pb push_back
#define fir(i,n) for(int i=0; i<n; i++)
#define vi vector<int>
#define  flush cout
#define VP vector<pair<int,int>>

void KONI(){
         
         int n,k;
         cin>>n>>k;
        vector<int>a(n);
        for(auto&k:a) {
          cin>>k;
        }
        sort(a.begin(),a.end());
        int cnt=1; int ans=1;
        for(int i=1; i<n; i++){
          if(abs(a[i]-a[i-1])<=k){
            cnt++;
          }
          else{
            ans=max(ans,cnt);
            cnt=1;
            
          }
          
        }
        ans=max(ans,cnt);
        
        cout<<(n-ans) <<endl;
        
        
        
        
        
        
        
    }
    signed main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    auto begin = std::chrono::high_resolution_clock::now();
    int t;
    cin>>t;
    while (t--)
    { 

        //cout << "Case #" << i << ": ";
        KONI(); 
        
    }
    auto end = std::chrono ::high_resolution_clock::now();
    auto elasped = std::chrono::duration_cast<std::chrono::nanoseconds>(end-begin);
    cerr<<"Time measured:"<< elasped. count()*1e-9<<"seconds.\n";
    return 0;
}
