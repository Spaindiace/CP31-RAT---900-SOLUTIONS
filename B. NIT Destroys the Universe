//all the best koyena for your jee mains and jee advanced. 
#include<bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
template<class Fun> class y_combinator_result {
 Fun fun_;
public:
template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}
template<class ...Args> decltype(auto) operator()(Args &&...args) {
   return fun_(std::ref(*this), std::forward<Args>(args)...);
    
      }
};
template<class Fun> decltype(auto) y_combinator(Fun &&fun) {
  return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); 
} // adding y-combinator 
using namespace __gnu_pbds;
using namespace std;
const int MOD = 1e9+7;
const int INP = 1e9;
#define ll long long
#pragma GCC optimize("O3,unroll-loops")
#define pb push_back
#define fir(i,n) for(int i=0; i<n; i++)
#define vi vector<int>
#define  flush cout


void KONI(){
     
        int n;
        cin>>n;
        vector<int>a(n);
        for(auto&k:a){
          cin>>k;
        }
        int ans=0;
       bool flag=false;
       for(int i=0; i<n; i++){
         if(a[i]!=0){
           if(!flag){
             ans++;
             flag=true;
           }
         }
         else{
           flag=false;
         }
       }
       if(ans>2){
         ans=2;
         
       }
      cout<<ans<<endl;
      
      
 
}
    signed main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    auto begin = std::chrono::high_resolution_clock::now();
     int t;
     cin>>t;
     while (t--)
    { 

        //cout << "Case #" << i << ": ";
        KONI(); 
        
    }
    auto end = std::chrono ::high_resolution_clock::now();
    auto elasped = std::chrono::duration_cast<std::chrono::nanoseconds>(end-begin);
    cerr<<"Time measured:"<< elasped. count()*1e-9<<"seconds.\n";
    return 0;
}
